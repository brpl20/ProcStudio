#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class StructureAnalyzer {
  constructor(rootPath) {
    this.rootPath = rootPath;
    this.ignorePaths = new Set([
      'node_modules',
      '.git',
      'dist',
      'build',
      '.vite',
      'coverage',
      '.nyc_output'
    ]);
    this.ignoreFiles = new Set([
      '.DS_Store',
      'package-lock.json',
      'yarn.lock',
      '.gitignore',
      '.env',
      '.env.local',
      'vite.config.ts.timestamp*'
    ]);
  }

  shouldIgnore(itemPath, isFile = false) {
    const name = path.basename(itemPath);

    if (isFile) {
      return this.ignoreFiles.has(name) || name.startsWith('.');
    }

    return this.ignorePaths.has(name) || name.startsWith('.');
  }

  analyzeDirectory(dirPath, level = 0, maxLevel = 4) {
    if (level > maxLevel) {
      return '';
    }

    const items = [];

    try {
      const dirContents = fs.readdirSync(dirPath, { withFileTypes: true });

      // Separate and sort directories and files
      const directories = dirContents
        .filter((item) => item.isDirectory() && !this.shouldIgnore(item.name))
        .sort((a, b) => a.name.localeCompare(b.name));

      const files = dirContents
        .filter((item) => item.isFile() && !this.shouldIgnore(item.name, true))
        .sort((a, b) => a.name.localeCompare(b.name));

      // Add directories first
      directories.forEach((dir) => {
        const fullPath = path.join(dirPath, dir.name);
        const indent = '  '.repeat(level);
        const hasContents = this.hasValidContents(fullPath);

        if (hasContents) {
          items.push(`${indent}${dir.name}: # `);
          const subContent = this.analyzeDirectory(fullPath, level + 1, maxLevel);
          if (subContent) {
            items.push(subContent);
          }
        }
      });

      // Add important files
      const importantFiles = files.filter((file) => this.isImportantFile(file.name));
      importantFiles.forEach((file) => {
        const indent = '  '.repeat(level);
        const description = this.getFileDescription(file.name);
        items.push(`${indent}${file.name}: # ${description || ''}`);
      });
    } catch (error) {
      // Silently skip directories we can't read
    }

    return items.join('\n');
  }

  hasValidContents(dirPath) {
    try {
      const contents = fs.readdirSync(dirPath, { withFileTypes: true });
      return contents.some((item) => {
        if (item.isFile()) {
          return !this.shouldIgnore(item.name, true);
        } else if (item.isDirectory()) {
          return (
            !this.shouldIgnore(item.name) && this.hasValidContents(path.join(dirPath, item.name))
          );
        }
        return false;
      });
    } catch {
      return false;
    }
  }

  isImportantFile(filename) {
    const importantExtensions = ['.ts', '.js', '.svelte', '.json', '.md'];
    const importantFiles = [
      'package.json',
      'vite.config.ts',
      'tsconfig.json',
      'tailwind.config.js',
      'README.md',
      'CLAUDE.md'
    ];

    return (
      importantFiles.includes(filename) || importantExtensions.some((ext) => filename.endsWith(ext))
    );
  }

  getFileDescription(filename) {
    const descriptions = {
      'package.json': 'Project dependencies and scripts',
      'vite.config.ts': 'Vite build configuration',
      'tsconfig.json': 'TypeScript configuration',
      'tailwind.config.js': 'Tailwind CSS configuration',
      'app.html': 'Main HTML template',
      'app.ts': 'Application entry point',
      'CLAUDE.md': 'AI development instructions'
    };

    return descriptions[filename] || '';
  }

  generateStructure() {
    const structure = this.analyzeDirectory(this.rootPath);

    const output = `# Frontend Project Structure
# Generated by ai-tools/structure-analyzer.js
# Use this file to understand the project organization
# Add comments at the end of lines to document purpose

frontend: # 
${structure}`;

    return output;
  }
}

// Main execution
if (import.meta.url === `file://${process.argv[1]}`) {
  const frontendPath = path.resolve(__dirname, '..');
  const analyzer = new StructureAnalyzer(frontendPath);

  try {
    const structure = analyzer.generateStructure();

    // Save to YAML file for reference
    const outputFile = path.join(__dirname, 'project-structure.yml');
    fs.writeFileSync(outputFile, structure);
  } catch (error) {
    process.exit(1);
  }
}

export default StructureAnalyzer;
